<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auslan Demo - Fingerspelling Recognition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
</head>
<body class="bg-gray-900 text-white">
    <div class="min-h-screen flex flex-col">
        <!-- Header -->
        <header class="bg-gray-800 p-4 border-b border-gray-700">
            <div class="max-w-7xl mx-auto flex justify-between items-center">
                <h1 class="text-2xl font-bold text-teal-400">Auslan Fingerspelling Recognition</h1>
                <a href="#" class="text-gray-400 hover:text-teal-300 text-sm">‚Üê Back</a>
            </div>
        </header>

        <!-- Mode Selection Screen -->
        <div id="mode-selection" class="flex-1 flex items-center justify-center bg-gradient-to-br from-gray-900 via-indigo-900 to-gray-900">
            <div class="text-center space-y-8">
                <h2 class="text-5xl font-bold mb-12">Choose a Mode</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-2xl">
                    <!-- Quiz Mode Card -->
                    <button id="quiz-mode-btn" class="bg-gradient-to-br from-purple-600 to-indigo-700 hover:from-purple-700 hover:to-indigo-800 p-8 rounded-xl transition-all transform hover:scale-105 cursor-pointer">
                        <div class="text-4xl mb-4">üéØ</div>
                        <h3 class="text-2xl font-bold mb-2">Quiz Mode</h3>
                        <p class="text-gray-300">Match the letter shown on screen</p>
                        <p class="text-xs text-gray-400 mt-3">Take your time to get it right</p>
                    </button>

                    <!-- Free Practice Card -->
                    <button id="practice-mode-btn" class="bg-gradient-to-br from-teal-600 to-cyan-700 hover:from-teal-700 hover:to-cyan-800 p-8 rounded-xl transition-all transform hover:scale-105 cursor-pointer">
                        <div class="text-4xl mb-4">üé®</div>
                        <h3 class="text-2xl font-bold mb-2">Free Practice</h3>
                        <p class="text-gray-300">Sign any letter and see predictions</p>
                        <p class="text-xs text-gray-400 mt-3">Explore and experiment freely</p>
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Demo Area (hidden initially) -->
        <div id="demo-area" class="hidden flex-1 flex flex-col lg:flex-row gap-4 p-4">
            <!-- Side Panel -->
            <div id="side-panel" class="w-full lg:w-80 bg-gradient-to-b from-indigo-900 via-purple-900 to-pink-900 p-6 rounded-lg flex flex-col justify-center items-center min-h-96 lg:min-h-screen">
                <div id="panel-content" class="text-center w-full space-y-6">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>

            <!-- Video Area -->
            <div class="flex-1 flex flex-col gap-4">
                <div class="relative bg-black rounded-lg overflow-hidden flex-1 flex items-center justify-center min-h-96">
                    <video id="video" autoplay playsinline muted class="w-full h-full object-cover" style="transform: scaleX(-1);"></video>
                    <canvas id="canvas" class="absolute inset-0 w-full h-full pointer-events-none" style="transform: scaleX(-1);"></canvas>
                    
                    <!-- Overlay Status -->
                    <div class="absolute top-4 left-4 bg-black bg-opacity-70 p-3 rounded text-sm">
                        <div>Status: <span id="status-text" class="text-teal-400">Loading models...</span></div>
                    </div>

                    <!-- Confidence Display -->
                    <div class="absolute bottom-4 right-4 bg-black bg-opacity-70 p-4 rounded text-sm max-w-xs">
                        <div class="text-gray-400 text-xs mb-2">Prediction</div>
                        <div class="text-2xl font-bold text-teal-400" id="prediction-display">--</div>
                        <div class="text-xs text-gray-300 mt-2">Confidence: <span id="confidence-display" class="text-yellow-400 font-semibold">--%</span></div>
                    </div>
                </div>

                <!-- Exit Button -->
                <button id="exit-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg transition-colors w-full">Exit to Mode Selection</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Constants
        const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
        const CONFIDENCE_THRESHOLD = 0.5;
        const CAPTURE_INTERVAL = 50; // ms
        
        const QUIZ_CONFIG = {
            TOTAL_FRAMES: 60,  // Increased from 20 for more generous timing
            SUCCESS_THRESHOLD: 0.75,
            MIN_CONFIDENCE: 0.65
        };

        const PRACTICE_CONFIG = {
            MIN_CONFIDENCE: 0.5
        };

        // State
        let handLandmarker = null;
        let model = null;
        let video = null;
        let canvas = null;
        let ctx = null;
        let captureInterval = null;
        let currentMode = null; // 'quiz' or 'practice'
        let quizStatus = 'idle'; // idle, in-progress, success, failure
        let quizLetter = null;
        let currentFrameCount = 0;
        let correctFrameCount = 0;
        let quizScore = 0;

        // Hand landmark connections
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],           // Thumb
            [0, 5], [5, 6], [6, 7], [7, 8],           // Index
            [0, 9], [9, 10], [10, 11], [11, 12],      // Middle
            [0, 13], [13, 14], [14, 15], [15, 16],    // Ring
            [0, 17], [17, 18], [18, 19], [19, 20]     // Pinky
        ];

        // Load MediaPipe
        async function loadMediaPipeLibrary() {
            if (window.HandLandmarker && window.FilesetResolver) return;
            
            updateStatus('Loading MediaPipe library...');
            try {
                const mediapipeModule = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3');
                window.HandLandmarker = mediapipeModule.HandLandmarker;
                window.FilesetResolver = mediapipeModule.FilesetResolver;
                console.log('MediaPipe loaded');
            } catch (e) {
                console.error('Failed to load MediaPipe:', e);
                throw e;
            }
        }

        // Initialize
        async function init() {
            // Setup mode selection first (before async operations)
            setupModeSelection();
            
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            try {
                updateStatus('Initializing...');
                await loadMediaPipeLibrary();
                
                if (!window.HandLandmarker || !window.FilesetResolver) {
                    throw new Error('MediaPipe library not available');
                }

                updateStatus('Initializing webcam...');
                await initWebcam();
                
                updateStatus('Loading models...');
                await Promise.all([loadMediaPipeModel(), loadTensorFlowModel()]);
                
                updateStatus('Ready');
                startCapture();
            } catch (error) {
                console.error('Init error:', error);
                updateStatus('Error: ' + error.message);
            }
        }

        // Setup mode selection
        function setupModeSelection() {
            const quizBtn = document.getElementById('quiz-mode-btn');
            const practiceBtn = document.getElementById('practice-mode-btn');
            const exitBtn = document.getElementById('exit-btn');
            
            console.log('Setting up mode selection:', { quizBtn, practiceBtn, exitBtn });
            
            if (quizBtn) {
                quizBtn.addEventListener('click', () => {
                    console.log('Quiz mode clicked');
                    startMode('quiz');
                });
            }
            if (practiceBtn) {
                practiceBtn.addEventListener('click', () => {
                    console.log('Practice mode clicked');
                    startMode('practice');
                });
            }
            if (exitBtn) {
                exitBtn.addEventListener('click', () => {
                    console.log('Exit clicked');
                    exitMode();
                });
            }
        }

        // Start mode
        function startMode(mode) {
            console.log('Starting mode:', mode);
            currentMode = mode;
            document.getElementById('mode-selection').classList.add('hidden');
            document.getElementById('demo-area').classList.remove('hidden');
            
            if (mode === 'quiz') {
                startNewQuiz();
            } else {
                updatePracticeUI();
            }
        }

        // Exit mode
        function exitMode() {
            console.log('Exiting mode');
            currentMode = null;
            quizStatus = 'idle';
            document.getElementById('mode-selection').classList.remove('hidden');
            document.getElementById('demo-area').classList.add('hidden');
        }

        // Initialize webcam
        async function initWebcam() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: { ideal: 1920 }, height: { ideal: 1440 }, facingMode: 'user' }
            });
            video.srcObject = stream;
            await video.play();
        }

        // Load MediaPipe model
        async function loadMediaPipeModel() {
            console.log('Loading MediaPipe model...');
            const HandLandmarker = window.HandLandmarker;
            const FilesetResolver = window.FilesetResolver;

            const vision = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm');
            
            const modelPaths = [
                './public/models/hand_landmarker.task',
            ];

            for (const modelPath of modelPaths) {
                try {
                    console.log('Trying model path:', modelPath);
                    handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: { modelAssetPath: modelPath },
                        runningMode: 'IMAGE',
                        numHands: 2,
                        minHandDetectionConfidence: 0.5,
                        minHandPresenceConfidence: 0.5
                    });
                    console.log('‚úì MediaPipe model loaded from:', modelPath);
                    return;
                } catch (e) {
                    console.log('‚úó Failed path:', modelPath, e.message);
                }
            }
            throw new Error('Could not load MediaPipe model from any path. Check console for details.');
        }

        // Load TensorFlow model
        async function loadTensorFlowModel() {
            console.log('Loading TensorFlow model...');
            const modelPaths = [
                './public/models/model.json',
            ];

            for (const modelPath of modelPaths) {
                try {
                    model = await tf.loadGraphModel(modelPath);
                    console.log('TensorFlow model loaded');
                    return;
                } catch (e) {
                    console.log('Failed path:', modelPath);
                }
            }
            console.warn('TensorFlow model not loaded - predictions will not work');
        }
        // Preprocess hand landmarks
        function preprocessHandLandmarks(handWorldLandmarks) {
            if (handWorldLandmarks.length < 1) {
                return tf.tensor([], [0, 0, 0], 'float32');
            }

            const coordinates = handWorldLandmarks.flatMap((handLandmarks) =>
                handLandmarks.map((landmark) => [landmark.x, landmark.y, landmark.z])
            );

            if (handWorldLandmarks.length === 1) {
                coordinates.push(...Array(21).fill([-1, -1, -1]));
            }

            return tf.tensor(coordinates)
                .reshape([2, 21, 3])
                .transpose([1, 2, 0])
                .expandDims();
        }

        // Get prediction
        async function getPrediction(landmarkTensor) {
            if (!model) {
                return { letter: 'No Model', confidence: 0 };
            }

            try {
                const prediction = model.predict(landmarkTensor);
                const probabilities = tf.softmax(prediction, 1);
                const maxProbability = (await probabilities.max().data())[0];
                const maxIndex = (await probabilities.argMax(1).data())[0];
                
                prediction.dispose();
                probabilities.dispose();

                const confidencePercent = (maxProbability * 100).toFixed(1);
                return {
                    letter: ALPHABET[maxIndex] || 'Unknown',
                    confidence: maxProbability,
                    confidencePercent
                };
            } catch (e) {
                console.error('Prediction error:', e);
                return { letter: 'Error', confidence: 0, confidencePercent: '0.0' };
            }
        }

        // Draw landmarks
        function drawLandmarks(landmarks) {
            if (!landmarks) return;

            // Draw connections
            ctx.strokeStyle = 'rgba(25, 150, 180, 0.7)';
            ctx.lineWidth = 3;

            for (const hand of landmarks) {
                HAND_CONNECTIONS.forEach(([start, end]) => {
                    if (hand[start] && hand[end]) {
                        ctx.beginPath();
                        ctx.moveTo(hand[start].x * canvas.width, hand[start].y * canvas.height);
                        ctx.lineTo(hand[end].x * canvas.width, hand[end].y * canvas.height);
                        ctx.stroke();
                    }
                });
            }

            // Draw joints
            ctx.fillStyle = 'rgba(0, 180, 220, 0.8)';
            for (const hand of landmarks) {
                for (const landmark of hand) {
                    ctx.beginPath();
                    ctx.arc(landmark.x * canvas.width, landmark.y * canvas.height, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        }

        // Process frame
        async function processFrame() {
            if (!video || !canvas || !handLandmarker || video.readyState !== 4) return;

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            ctx.drawImage(video, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const results = handLandmarker.detect(imageData);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 0, 0);

            if (results.landmarks && results.landmarks.length > 0) {
                drawLandmarks(results.landmarks);

                const landmarkTensor = preprocessHandLandmarks(results.worldLandmarks);
                const predictionResult = await getPrediction(landmarkTensor);
                
                // Update confidence display
                document.getElementById('prediction-display').textContent = predictionResult.letter;
                document.getElementById('confidence-display').textContent = predictionResult.confidencePercent + '%';

                // Process quiz logic
                if (currentMode === 'quiz' && quizStatus === 'in-progress') {
                    currentFrameCount++;
                    
                    if (predictionResult.letter === quizLetter && predictionResult.confidence >= QUIZ_CONFIG.MIN_CONFIDENCE) {
                        correctFrameCount++;
                    }

                    if (currentFrameCount >= QUIZ_CONFIG.TOTAL_FRAMES) {
                        if (correctFrameCount / QUIZ_CONFIG.TOTAL_FRAMES >= QUIZ_CONFIG.SUCCESS_THRESHOLD) {
                            quizStatus = 'success';
                            quizScore++;
                        } else {
                            quizStatus = 'failure';
                        }
                        updateQuizUI();
                    } else {
                        updateQuizProgress();
                    }
                }

                landmarkTensor.dispose();
            } else {
                document.getElementById('prediction-display').textContent = '--';
                document.getElementById('confidence-display').textContent = '--%';
            }
        }

        // Start capture
        function startCapture() {
            if (captureInterval) clearInterval(captureInterval);
            captureInterval = setInterval(processFrame, CAPTURE_INTERVAL);
        }

        // Start new quiz
        function startNewQuiz() {
            if (!model) {
                alert('Model is still loading. Please wait...');
                return;
            }
            quizLetter = ALPHABET[Math.floor(Math.random() * 5)]; // A-E
            currentFrameCount = 0;
            correctFrameCount = 0;
            quizStatus = 'in-progress';
            updateQuizUI();
        }

        // Update quiz UI
        function updateQuizUI() {
            const panelContent = document.getElementById('panel-content');
            const progressPercentage = quizStatus === 'in-progress' 
                ? (correctFrameCount / QUIZ_CONFIG.TOTAL_FRAMES) * 100 
                : 0;

            if (quizStatus === 'in-progress') {
                const progressColor = progressPercentage < 20 ? 'bg-red-500' : 
                                     progressPercentage < 50 ? 'bg-yellow-500' : 'bg-green-500';
                
                panelContent.innerHTML = `
                    <p class="text-gray-400 text-sm">Show the letter:</p>
                    <p class="text-9xl font-bold text-blue-400 my-8">${quizLetter}</p>
                    <div class="w-full bg-gray-700 rounded-full h-4 overflow-hidden">
                        <div class="${progressColor} h-full rounded-full transition-all duration-300" style="width: ${progressPercentage}%"></div>
                    </div>
                    <p class="text-xs text-gray-400 mt-4">${Math.round(progressPercentage)}% Complete</p>
                    <p class="text-sm text-gray-300 mt-6">Score: <span class="text-teal-400 font-bold">${quizScore}</span></p>
                `;
            } else if (quizStatus === 'success') {
                panelContent.innerHTML = `
                    <div class="text-6xl mb-6">‚úÖ</div>
                    <p class="text-3xl font-bold text-green-400 mb-6">Correct!</p>
                    <p class="text-lg text-gray-300 mb-8">Great job! You got it right!</p>
                    <p class="text-sm text-gray-300 mb-8">Score: <span class="text-teal-400 font-bold">${quizScore}</span></p>
                    <button class="bg-purple-600 hover:bg-purple-700 text-white px-8 py-3 rounded-lg font-bold transition-colors">
                        Next Letter
                    </button>
                `;
                document.querySelector('button:last-child').addEventListener('click', startNewQuiz);
            } else if (quizStatus === 'failure') {
                panelContent.innerHTML = `
                    <div class="text-6xl mb-6">‚ùå</div>
                    <p class="text-3xl font-bold text-red-400 mb-6">Not Quite!</p>
                    <p class="text-lg text-gray-300 mb-2">You needed to show:</p>
                    <p class="text-6xl font-bold text-yellow-400 mb-8">${quizLetter}</p>
                    <p class="text-sm text-gray-300 mb-8">Score: <span class="text-teal-400 font-bold">${quizScore}</span></p>
                    <button class="bg-red-600 hover:bg-red-700 text-white px-8 py-3 rounded-lg font-bold transition-colors">
                        Try Again
                    </button>
                `;
                document.querySelector('button:last-child').addEventListener('click', startNewQuiz);
            }
        }

        // Update practice UI
        function updatePracticeUI() {
            const panelContent = document.getElementById('panel-content');
            panelContent.innerHTML = `
                <div class="text-5xl mb-6">üé®</div>
                <p class="text-2xl font-bold mb-4">Free Practice</p>
                <p class="text-gray-300 text-sm mb-8">Sign any letter! The model will predict what you're signing in real-time.</p>
                <div class="bg-indigo-800 rounded-lg p-4 text-left">
                    <p class="text-xs text-gray-400 mb-2">üí° Tips:</p>
                    <ul class="text-xs text-gray-300 space-y-1">
                        <li>‚Ä¢ Keep your hand in frame</li>
                        <li>‚Ä¢ Show clear finger positions</li>
                        <li>‚Ä¢ Watch confidence scores</li>
                        <li>‚Ä¢ Experiment with poses</li>
                    </ul>
                </div>
            `;
        }

        // Update quiz progress
        function updateQuizProgress() {
            const progressPercentage = (correctFrameCount / QUIZ_CONFIG.TOTAL_FRAMES) * 100;
            const progressColor = progressPercentage < 20 ? 'bg-red-500' : 
                                 progressPercentage < 50 ? 'bg-yellow-500' : 'bg-green-500';
            
            const progressBar = document.querySelector('#panel-content .rounded-full');
            if (progressBar) {
                const fill = progressBar.querySelector('div');
                if (fill) {
                    fill.className = `${progressColor} h-full rounded-full transition-all duration-300`;
                    fill.style.width = progressPercentage + '%';
                }
            }
        }

        // Update status
        function updateStatus(text) {
            document.getElementById('status-text').textContent = text;
        }

        // Start on load
        window.addEventListener('load', init);
    </script>
</body>
</html>
